/*
Sumo Logic API

Go client for Sumo Logic API

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sumologic

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ContentManagementApiService ContentManagementApi service
type ContentManagementApiService service

type ApiAsyncCopyStatusRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	id string
	jobId string
	isAdminMode *string
}

// Set this to \&quot;true\&quot; if you want to perform the request as a Content Administrator.
func (r ApiAsyncCopyStatusRequest) IsAdminMode(isAdminMode string) ApiAsyncCopyStatusRequest {
	r.isAdminMode = &isAdminMode
	return r
}

func (r ApiAsyncCopyStatusRequest) Execute() (*AsyncJobStatus, *http.Response, error) {
	return r.ApiService.AsyncCopyStatusExecute(r)
}

/*
AsyncCopyStatus Content copy job status.

Get the status of the copy request with the given job identifier. On success, field `statusMessage` will contain identifier of the newly copied content in format: `id: {hexIdentifier}`.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The identifier of the content which was copied.
 @param jobId The identifier of the asynchronous copy request job.
 @return ApiAsyncCopyStatusRequest
*/
func (a *ContentManagementApiService) AsyncCopyStatus(ctx context.Context, id string, jobId string) ApiAsyncCopyStatusRequest {
	return ApiAsyncCopyStatusRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return AsyncJobStatus
func (a *ContentManagementApiService) AsyncCopyStatusExecute(r ApiAsyncCopyStatusRequest) (*AsyncJobStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.AsyncCopyStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/{id}/copy/{jobId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isAdminMode != nil {
		localVarHeaderParams["isAdminMode"] = parameterToString(*r.isAdminMode, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBeginAsyncCopyRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	id string
	destinationFolder *string
	isAdminMode *string
}

// The identifier of the destination folder.
func (r ApiBeginAsyncCopyRequest) DestinationFolder(destinationFolder string) ApiBeginAsyncCopyRequest {
	r.destinationFolder = &destinationFolder
	return r
}

// Set this to \&quot;true\&quot; if you want to perform the request as a Content Administrator.
func (r ApiBeginAsyncCopyRequest) IsAdminMode(isAdminMode string) ApiBeginAsyncCopyRequest {
	r.isAdminMode = &isAdminMode
	return r
}

func (r ApiBeginAsyncCopyRequest) Execute() (*BeginAsyncJobResponse, *http.Response, error) {
	return r.ApiService.BeginAsyncCopyExecute(r)
}

/*
BeginAsyncCopy Start a content copy job.

Start an asynchronous content copy job with the given identifier to the destination folder. If the content item is a folder, everything under the folder is copied recursively.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The identifier of the content item to copy. Identifiers from the Library in the Sumo user interface are provided in decimal format which is incompatible with this API. The identifier needs to be in hexadecimal format.
 @return ApiBeginAsyncCopyRequest
*/
func (a *ContentManagementApiService) BeginAsyncCopy(ctx context.Context, id string) ApiBeginAsyncCopyRequest {
	return ApiBeginAsyncCopyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BeginAsyncJobResponse
func (a *ContentManagementApiService) BeginAsyncCopyExecute(r ApiBeginAsyncCopyRequest) (*BeginAsyncJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BeginAsyncJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.BeginAsyncCopy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/{id}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.destinationFolder == nil {
		return localVarReturnValue, nil, reportError("destinationFolder is required and must be specified")
	}

	localVarQueryParams.Add("destinationFolder", parameterToString(*r.destinationFolder, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isAdminMode != nil {
		localVarHeaderParams["isAdminMode"] = parameterToString(*r.isAdminMode, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBeginAsyncDeleteRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	id string
	isAdminMode *string
}

// Set this to \&quot;true\&quot; if you want to perform the request as a Content Administrator.
func (r ApiBeginAsyncDeleteRequest) IsAdminMode(isAdminMode string) ApiBeginAsyncDeleteRequest {
	r.isAdminMode = &isAdminMode
	return r
}

func (r ApiBeginAsyncDeleteRequest) Execute() (*BeginAsyncJobResponse, *http.Response, error) {
	return r.ApiService.BeginAsyncDeleteExecute(r)
}

/*
BeginAsyncDelete Start a content deletion job.

Start an asynchronous content deletion job with the given identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifier of the content to delete. Identifiers from the Library in the Sumo user interface are provided in decimal format which is incompatible with this API. The identifier needs to be in hexadecimal format.
 @return ApiBeginAsyncDeleteRequest
*/
func (a *ContentManagementApiService) BeginAsyncDelete(ctx context.Context, id string) ApiBeginAsyncDeleteRequest {
	return ApiBeginAsyncDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BeginAsyncJobResponse
func (a *ContentManagementApiService) BeginAsyncDeleteExecute(r ApiBeginAsyncDeleteRequest) (*BeginAsyncJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BeginAsyncJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.BeginAsyncDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/{id}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isAdminMode != nil {
		localVarHeaderParams["isAdminMode"] = parameterToString(*r.isAdminMode, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBeginAsyncExportRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	id string
	isAdminMode *string
}

// Set this to \&quot;true\&quot; if you want to perform the request as a Content Administrator.
func (r ApiBeginAsyncExportRequest) IsAdminMode(isAdminMode string) ApiBeginAsyncExportRequest {
	r.isAdminMode = &isAdminMode
	return r
}

func (r ApiBeginAsyncExportRequest) Execute() (*BeginAsyncJobResponse, *http.Response, error) {
	return r.ApiService.BeginAsyncExportExecute(r)
}

/*
BeginAsyncExport Start a content export job.

Schedule an _asynchronous_ export of content with the given identifier. You will get back an asynchronous job identifier on success. Use the [getAsyncExportStatus](#operation/getAsyncExportStatus) endpoint and the job identifier you got back in the response to track the status of an asynchronous export job.
If the content item is a folder, everything under the folder is exported recursively. Keep in mind when exporting large folders that there is a limit of 1000 content objects that can be exported at once. If you want to import more than 1000 content objects, then be sure to split the import into batches of 1000 objects or less.
The results from the export are compatible with the Library import feature in the Sumo Logic user interface as well as the API content import job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The identifier of the content item to export. Identifiers from the Library in the Sumo user interface are provided in decimal format which is incompatible with this API. The identifier needs to be in hexadecimal format.
 @return ApiBeginAsyncExportRequest
*/
func (a *ContentManagementApiService) BeginAsyncExport(ctx context.Context, id string) ApiBeginAsyncExportRequest {
	return ApiBeginAsyncExportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BeginAsyncJobResponse
func (a *ContentManagementApiService) BeginAsyncExportExecute(r ApiBeginAsyncExportRequest) (*BeginAsyncJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BeginAsyncJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.BeginAsyncExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/{id}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isAdminMode != nil {
		localVarHeaderParams["isAdminMode"] = parameterToString(*r.isAdminMode, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBeginAsyncImportRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	folderId string
	contentSyncDefinition *ContentSyncDefinition
	isAdminMode *string
	overwrite *bool
}

// The content to import.
func (r ApiBeginAsyncImportRequest) ContentSyncDefinition(contentSyncDefinition ContentSyncDefinition) ApiBeginAsyncImportRequest {
	r.contentSyncDefinition = &contentSyncDefinition
	return r
}

// Set this to \&quot;true\&quot; if you want to perform the request as a Content Administrator.
func (r ApiBeginAsyncImportRequest) IsAdminMode(isAdminMode string) ApiBeginAsyncImportRequest {
	r.isAdminMode = &isAdminMode
	return r
}

// Set this to \&quot;true\&quot; to overwrite a content item if the name already exists.
func (r ApiBeginAsyncImportRequest) Overwrite(overwrite bool) ApiBeginAsyncImportRequest {
	r.overwrite = &overwrite
	return r
}

func (r ApiBeginAsyncImportRequest) Execute() (*BeginAsyncJobResponse, *http.Response, error) {
	return r.ApiService.BeginAsyncImportExecute(r)
}

/*
BeginAsyncImport Start a content import job.

Schedule an asynchronous import of content inside an existing folder with the given identifier. Import requests can be used to create or update content within a folder. Content items need to have a unique name within their folder. If there is already a content item with the same name in the folder, you can set the `overwrite` parameter to `true` to overwrite existing content items. By default, the `overwrite` parameter is set to `false`, where the import will fail if a content item with the same name already exist. Keep in mind when importing large folders that there is a limit of 1000 content objects that can be imported at once. If you want to import more than 1000 content objects, then be sure to split the import into batches of 1000 objects or less.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folderId The identifier of the folder to import into. Identifiers from the Library in the Sumo user interface are provided in decimal format which is incompatible with this API. The identifier needs to be in hexadecimal format.
 @return ApiBeginAsyncImportRequest
*/
func (a *ContentManagementApiService) BeginAsyncImport(ctx context.Context, folderId string) ApiBeginAsyncImportRequest {
	return ApiBeginAsyncImportRequest{
		ApiService: a,
		ctx: ctx,
		folderId: folderId,
	}
}

// Execute executes the request
//  @return BeginAsyncJobResponse
func (a *ContentManagementApiService) BeginAsyncImportExecute(r ApiBeginAsyncImportRequest) (*BeginAsyncJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BeginAsyncJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.BeginAsyncImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/folders/{folderId}/import"
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(parameterToString(r.folderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentSyncDefinition == nil {
		return localVarReturnValue, nil, reportError("contentSyncDefinition is required and must be specified")
	}

	if r.overwrite != nil {
		localVarQueryParams.Add("overwrite", parameterToString(*r.overwrite, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isAdminMode != nil {
		localVarHeaderParams["isAdminMode"] = parameterToString(*r.isAdminMode, "")
	}
	// body params
	localVarPostBody = r.contentSyncDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAsyncDeleteStatusRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	id string
	jobId string
	isAdminMode *string
}

// Set this to \&quot;true\&quot; if you want to perform the request as a Content Administrator.
func (r ApiGetAsyncDeleteStatusRequest) IsAdminMode(isAdminMode string) ApiGetAsyncDeleteStatusRequest {
	r.isAdminMode = &isAdminMode
	return r
}

func (r ApiGetAsyncDeleteStatusRequest) Execute() (*AsyncJobStatus, *http.Response, error) {
	return r.ApiService.GetAsyncDeleteStatusExecute(r)
}

/*
GetAsyncDeleteStatus Content deletion job status.

Get the status of an asynchronous content deletion job request for the given job identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifier of the content to delete.
 @param jobId The identifier of the asynchronous job.
 @return ApiGetAsyncDeleteStatusRequest
*/
func (a *ContentManagementApiService) GetAsyncDeleteStatus(ctx context.Context, id string, jobId string) ApiGetAsyncDeleteStatusRequest {
	return ApiGetAsyncDeleteStatusRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return AsyncJobStatus
func (a *ContentManagementApiService) GetAsyncDeleteStatusExecute(r ApiGetAsyncDeleteStatusRequest) (*AsyncJobStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.GetAsyncDeleteStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/{id}/delete/{jobId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isAdminMode != nil {
		localVarHeaderParams["isAdminMode"] = parameterToString(*r.isAdminMode, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAsyncExportResultRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	contentId string
	jobId string
	isAdminMode *string
}

// Set this to \&quot;true\&quot; if you want to perform the request as a Content Administrator.
func (r ApiGetAsyncExportResultRequest) IsAdminMode(isAdminMode string) ApiGetAsyncExportResultRequest {
	r.isAdminMode = &isAdminMode
	return r
}

func (r ApiGetAsyncExportResultRequest) Execute() (*ContentSyncDefinition, *http.Response, error) {
	return r.ApiService.GetAsyncExportResultExecute(r)
}

/*
GetAsyncExportResult Content export job result.

Get results from content export job for the given job identifier. The results from this export are incompatible with the Library import feature in the Sumo user interface.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentId The identifier of the exported content item.
 @param jobId The identifier of the asynchronous job.
 @return ApiGetAsyncExportResultRequest
*/
func (a *ContentManagementApiService) GetAsyncExportResult(ctx context.Context, contentId string, jobId string) ApiGetAsyncExportResultRequest {
	return ApiGetAsyncExportResultRequest{
		ApiService: a,
		ctx: ctx,
		contentId: contentId,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return ContentSyncDefinition
func (a *ContentManagementApiService) GetAsyncExportResultExecute(r ApiGetAsyncExportResultRequest) (*ContentSyncDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentSyncDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.GetAsyncExportResult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/{contentId}/export/{jobId}/result"
	localVarPath = strings.Replace(localVarPath, "{"+"contentId"+"}", url.PathEscape(parameterToString(r.contentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isAdminMode != nil {
		localVarHeaderParams["isAdminMode"] = parameterToString(*r.isAdminMode, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAsyncExportStatusRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	contentId string
	jobId string
	isAdminMode *string
}

// Set this to \&quot;true\&quot; if you want to perform the request as a Content Administrator.
func (r ApiGetAsyncExportStatusRequest) IsAdminMode(isAdminMode string) ApiGetAsyncExportStatusRequest {
	r.isAdminMode = &isAdminMode
	return r
}

func (r ApiGetAsyncExportStatusRequest) Execute() (*AsyncJobStatus, *http.Response, error) {
	return r.ApiService.GetAsyncExportStatusExecute(r)
}

/*
GetAsyncExportStatus Content export job status.

Get the status of an asynchronous content export request for the given job identifier. On success, use the [getExportResult](#operation/getAsyncExportResult) endpoint to get the result of the export job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentId The identifier of the exported content item.
 @param jobId The identifier of the asynchronous export job.
 @return ApiGetAsyncExportStatusRequest
*/
func (a *ContentManagementApiService) GetAsyncExportStatus(ctx context.Context, contentId string, jobId string) ApiGetAsyncExportStatusRequest {
	return ApiGetAsyncExportStatusRequest{
		ApiService: a,
		ctx: ctx,
		contentId: contentId,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return AsyncJobStatus
func (a *ContentManagementApiService) GetAsyncExportStatusExecute(r ApiGetAsyncExportStatusRequest) (*AsyncJobStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.GetAsyncExportStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/{contentId}/export/{jobId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"contentId"+"}", url.PathEscape(parameterToString(r.contentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isAdminMode != nil {
		localVarHeaderParams["isAdminMode"] = parameterToString(*r.isAdminMode, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAsyncImportStatusRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	folderId string
	jobId string
	isAdminMode *string
}

// Set this to \&quot;true\&quot; if you want to perform the request as a Content Administrator.
func (r ApiGetAsyncImportStatusRequest) IsAdminMode(isAdminMode string) ApiGetAsyncImportStatusRequest {
	r.isAdminMode = &isAdminMode
	return r
}

func (r ApiGetAsyncImportStatusRequest) Execute() (*AsyncJobStatus, *http.Response, error) {
	return r.ApiService.GetAsyncImportStatusExecute(r)
}

/*
GetAsyncImportStatus Content import job status.

Get the status of a content import job for the given job identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param folderId The identifier of the folder to import into.
 @param jobId The identifier of the import request.
 @return ApiGetAsyncImportStatusRequest
*/
func (a *ContentManagementApiService) GetAsyncImportStatus(ctx context.Context, folderId string, jobId string) ApiGetAsyncImportStatusRequest {
	return ApiGetAsyncImportStatusRequest{
		ApiService: a,
		ctx: ctx,
		folderId: folderId,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return AsyncJobStatus
func (a *ContentManagementApiService) GetAsyncImportStatusExecute(r ApiGetAsyncImportStatusRequest) (*AsyncJobStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AsyncJobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.GetAsyncImportStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/folders/{folderId}/import/{jobId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"folderId"+"}", url.PathEscape(parameterToString(r.folderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterToString(r.jobId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isAdminMode != nil {
		localVarHeaderParams["isAdminMode"] = parameterToString(*r.isAdminMode, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemByPathRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	path *string
}

// Path of the content item to retrieve.
func (r ApiGetItemByPathRequest) Path(path string) ApiGetItemByPathRequest {
	r.path = &path
	return r
}

func (r ApiGetItemByPathRequest) Execute() (*Content, *http.Response, error) {
	return r.ApiService.GetItemByPathExecute(r)
}

/*
GetItemByPath Get content item by path.

Get a content item corresponding to the given path.

_Path is specified in the required query parameter `path`. The path should be URL encoded._ For example, to get "Acme Corp" folder of a user "user@sumo.com" you can use the following curl command:
  ```bash
  curl https://api.sumologic.com/api/v2/content/path?path=/Library/Users/user%40sumo.com/Acme%20Corp
  ```


The absolute path to a content item should be specified to get the item. The content library has "Library" folder at the root level. For items in "Personal" folder, the base path is "/Library/Users/user@sumo.com" where "user@sumo.com" is the email address of the user. For example if a user with email address `wile@acme.com` has `Rockets` folder inside Personal folder, the path of Rockets folder will be `/Library/Users/wile@acme.com/Rockets`.

For items in "Admin Recommended" folder, the base path is "/Library/Admin Recommended". For example, given a folder `Acme` in Admin Recommended folder, the path will be `/Library/Admin Recommended/Acme`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetItemByPathRequest
*/
func (a *ContentManagementApiService) GetItemByPath(ctx context.Context) ApiGetItemByPathRequest {
	return ApiGetItemByPathRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Content
func (a *ContentManagementApiService) GetItemByPathExecute(r ApiGetItemByPathRequest) (*Content, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Content
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.GetItemByPath")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/path"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}

	localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPathByIdRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	contentId string
}

func (r ApiGetPathByIdRequest) Execute() (*ContentPath, *http.Response, error) {
	return r.ApiService.GetPathByIdExecute(r)
}

/*
GetPathById Get path of an item.

Get full path of a content item with the given identifier.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentId Identifier of the content item to get the path.
 @return ApiGetPathByIdRequest
*/
func (a *ContentManagementApiService) GetPathById(ctx context.Context, contentId string) ApiGetPathByIdRequest {
	return ApiGetPathByIdRequest{
		ApiService: a,
		ctx: ctx,
		contentId: contentId,
	}
}

// Execute executes the request
//  @return ContentPath
func (a *ContentManagementApiService) GetPathByIdExecute(r ApiGetPathByIdRequest) (*ContentPath, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentPath
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.GetPathById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/{contentId}/path"
	localVarPath = strings.Replace(localVarPath, "{"+"contentId"+"}", url.PathEscape(parameterToString(r.contentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoveItemRequest struct {
	ctx context.Context
	ApiService *ContentManagementApiService
	destinationFolderId *string
	id string
	isAdminMode *string
}

// Identifier of the destination folder.
func (r ApiMoveItemRequest) DestinationFolderId(destinationFolderId string) ApiMoveItemRequest {
	r.destinationFolderId = &destinationFolderId
	return r
}

// Set this to \&quot;true\&quot; if you want to perform the request as a Content Administrator.
func (r ApiMoveItemRequest) IsAdminMode(isAdminMode string) ApiMoveItemRequest {
	r.isAdminMode = &isAdminMode
	return r
}

func (r ApiMoveItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.MoveItemExecute(r)
}

/*
MoveItem Move an item.

Moves an item from its current location to another folder.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifier of the item the user wants to move.
 @return ApiMoveItemRequest
*/
func (a *ContentManagementApiService) MoveItem(ctx context.Context, id string) ApiMoveItemRequest {
	return ApiMoveItemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ContentManagementApiService) MoveItemExecute(r ApiMoveItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContentManagementApiService.MoveItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/content/{id}/move"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.destinationFolderId == nil {
		return nil, reportError("destinationFolderId is required and must be specified")
	}

	localVarQueryParams.Add("destinationFolderId", parameterToString(*r.destinationFolderId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.isAdminMode != nil {
		localVarHeaderParams["isAdminMode"] = parameterToString(*r.isAdminMode, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
