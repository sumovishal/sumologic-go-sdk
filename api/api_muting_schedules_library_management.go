/*
Sumo Logic API

Go client for Sumo Logic API. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// MutingSchedulesLibraryManagementApiService MutingSchedulesLibraryManagementApi service
type MutingSchedulesLibraryManagementApiService service

type ApiGetMutingSchedulesFullPathRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
	id string
}

func (r ApiGetMutingSchedulesFullPathRequest) Execute() (*Path, *http.Response, error) {
	return r.ApiService.GetMutingSchedulesFullPathExecute(r)
}

/*
GetMutingSchedulesFullPath Get the path of a mutingschedule or folder.

Get the full path of the mutingschedule or folder in the mutingSchedules library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifier of the mutingschedule or folder.
 @return ApiGetMutingSchedulesFullPathRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) GetMutingSchedulesFullPath(ctx context.Context, id string) ApiGetMutingSchedulesFullPathRequest {
	return ApiGetMutingSchedulesFullPathRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Path
func (a *MutingSchedulesLibraryManagementApiService) GetMutingSchedulesFullPathExecute(r ApiGetMutingSchedulesFullPathRequest) (*Path, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Path
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.GetMutingSchedulesFullPath")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules/{id}/path"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMutingSchedulesLibraryRootRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
}

func (r ApiGetMutingSchedulesLibraryRootRequest) Execute() (*MutingSchedulesLibraryFolderResponse, *http.Response, error) {
	return r.ApiService.GetMutingSchedulesLibraryRootExecute(r)
}

/*
GetMutingSchedulesLibraryRoot Get the root mutingSchedules folder.

Get the root folder in the mutingSchedules library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMutingSchedulesLibraryRootRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) GetMutingSchedulesLibraryRoot(ctx context.Context) ApiGetMutingSchedulesLibraryRootRequest {
	return ApiGetMutingSchedulesLibraryRootRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MutingSchedulesLibraryFolderResponse
func (a *MutingSchedulesLibraryManagementApiService) GetMutingSchedulesLibraryRootExecute(r ApiGetMutingSchedulesLibraryRootRequest) (*MutingSchedulesLibraryFolderResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MutingSchedulesLibraryFolderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.GetMutingSchedulesLibraryRoot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules/root"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMutingSchedulesCopyRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
	id string
	contentCopyParams *ContentCopyParams
}

// Fields include:   1) Identifier of the parent folder to copy to.   2) Optionally provide a new name.   3) Optionally provide a new description.   4) Optionally set to true if you want to copy and preserve the locked status. Requires &#x60;LockMutingSchedules&#x60; capability.
func (r ApiMutingSchedulesCopyRequest) ContentCopyParams(contentCopyParams ContentCopyParams) ApiMutingSchedulesCopyRequest {
	r.contentCopyParams = &contentCopyParams
	return r
}

func (r ApiMutingSchedulesCopyRequest) Execute() (*MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	return r.ApiService.MutingSchedulesCopyExecute(r)
}

/*
MutingSchedulesCopy Copy a mutingschedule or folder.

Copy a mutingschedule or folder in the mutingSchedules library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifier of the mutingschedule or folder to copy.
 @return ApiMutingSchedulesCopyRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesCopy(ctx context.Context, id string) ApiMutingSchedulesCopyRequest {
	return ApiMutingSchedulesCopyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MutingSchedulesLibraryBaseResponse
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesCopyExecute(r ApiMutingSchedulesCopyRequest) (*MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MutingSchedulesLibraryBaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.MutingSchedulesCopy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules/{id}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentCopyParams == nil {
		return localVarReturnValue, nil, reportError("contentCopyParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentCopyParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMutingSchedulesCreateRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
	parentId *string
	mutingSchedulesLibraryBase *MutingSchedulesLibraryBase
}

// Identifier of the parent folder in which to create the mutingschedule or folder.
func (r ApiMutingSchedulesCreateRequest) ParentId(parentId string) ApiMutingSchedulesCreateRequest {
	r.parentId = &parentId
	return r
}

// The mutingschedule or folder to create.
func (r ApiMutingSchedulesCreateRequest) MutingSchedulesLibraryBase(mutingSchedulesLibraryBase MutingSchedulesLibraryBase) ApiMutingSchedulesCreateRequest {
	r.mutingSchedulesLibraryBase = &mutingSchedulesLibraryBase
	return r
}

func (r ApiMutingSchedulesCreateRequest) Execute() (*MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	return r.ApiService.MutingSchedulesCreateExecute(r)
}

/*
MutingSchedulesCreate Create a mutingschedule or folder. 

Create a mutingschedule or folder in the mutingSchedules library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMutingSchedulesCreateRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesCreate(ctx context.Context) ApiMutingSchedulesCreateRequest {
	return ApiMutingSchedulesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MutingSchedulesLibraryBaseResponse
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesCreateExecute(r ApiMutingSchedulesCreateRequest) (*MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MutingSchedulesLibraryBaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.MutingSchedulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.parentId == nil {
		return localVarReturnValue, nil, reportError("parentId is required and must be specified")
	}
	if r.mutingSchedulesLibraryBase == nil {
		return localVarReturnValue, nil, reportError("mutingSchedulesLibraryBase is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mutingSchedulesLibraryBase
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMutingSchedulesDeleteByIdRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
	id string
}

func (r ApiMutingSchedulesDeleteByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.MutingSchedulesDeleteByIdExecute(r)
}

/*
MutingSchedulesDeleteById Delete a mutingschedule or folder. 

Delete a mutingschedule or folder from the mutingSchedules library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifier of the mutingschedule or folder to delete.
 @return ApiMutingSchedulesDeleteByIdRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesDeleteById(ctx context.Context, id string) ApiMutingSchedulesDeleteByIdRequest {
	return ApiMutingSchedulesDeleteByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesDeleteByIdExecute(r ApiMutingSchedulesDeleteByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.MutingSchedulesDeleteById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMutingSchedulesDeleteByIdsRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
	ids *[]string
}

// A comma-separated list of identifiers.
func (r ApiMutingSchedulesDeleteByIdsRequest) Ids(ids []string) ApiMutingSchedulesDeleteByIdsRequest {
	r.ids = &ids
	return r
}

func (r ApiMutingSchedulesDeleteByIdsRequest) Execute() (*map[string]MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	return r.ApiService.MutingSchedulesDeleteByIdsExecute(r)
}

/*
MutingSchedulesDeleteByIds Bulk delete a mutingschedule or folder. 

Bulk delete a mutingschedule or folder by the given identifiers in the mutingSchedules library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMutingSchedulesDeleteByIdsRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesDeleteByIds(ctx context.Context) ApiMutingSchedulesDeleteByIdsRequest {
	return ApiMutingSchedulesDeleteByIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]MutingSchedulesLibraryBaseResponse
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesDeleteByIdsExecute(r ApiMutingSchedulesDeleteByIdsRequest) (*map[string]MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]MutingSchedulesLibraryBaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.MutingSchedulesDeleteByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMutingSchedulesExportItemRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
	id string
}

func (r ApiMutingSchedulesExportItemRequest) Execute() (*MutingSchedulesLibraryBaseExport, *http.Response, error) {
	return r.ApiService.MutingSchedulesExportItemExecute(r)
}

/*
MutingSchedulesExportItem Export a mutingschedule or folder.

Export a mutingschedule or folder. If the given identifier is a folder, everything under the folder is exported recursively with folder as the root.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifier of the mutingschedule or folder to export.
 @return ApiMutingSchedulesExportItemRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesExportItem(ctx context.Context, id string) ApiMutingSchedulesExportItemRequest {
	return ApiMutingSchedulesExportItemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MutingSchedulesLibraryBaseExport
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesExportItemExecute(r ApiMutingSchedulesExportItemRequest) (*MutingSchedulesLibraryBaseExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MutingSchedulesLibraryBaseExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.MutingSchedulesExportItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules/{id}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMutingSchedulesImportItemRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
	parentId string
	mutingSchedulesLibraryBaseExport *MutingSchedulesLibraryBaseExport
}

// The mutingschedule or folder to be imported.
func (r ApiMutingSchedulesImportItemRequest) MutingSchedulesLibraryBaseExport(mutingSchedulesLibraryBaseExport MutingSchedulesLibraryBaseExport) ApiMutingSchedulesImportItemRequest {
	r.mutingSchedulesLibraryBaseExport = &mutingSchedulesLibraryBaseExport
	return r
}

func (r ApiMutingSchedulesImportItemRequest) Execute() (*MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	return r.ApiService.MutingSchedulesImportItemExecute(r)
}

/*
MutingSchedulesImportItem Import a mutingschedule or folder.

Import a mutingschedule or folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentId Identifier of the parent folder in which to import the mutingschedule or folder.
 @return ApiMutingSchedulesImportItemRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesImportItem(ctx context.Context, parentId string) ApiMutingSchedulesImportItemRequest {
	return ApiMutingSchedulesImportItemRequest{
		ApiService: a,
		ctx: ctx,
		parentId: parentId,
	}
}

// Execute executes the request
//  @return MutingSchedulesLibraryBaseResponse
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesImportItemExecute(r ApiMutingSchedulesImportItemRequest) (*MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MutingSchedulesLibraryBaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.MutingSchedulesImportItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules/{parentId}/import"
	localVarPath = strings.Replace(localVarPath, "{"+"parentId"+"}", url.PathEscape(parameterValueToString(r.parentId, "parentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mutingSchedulesLibraryBaseExport == nil {
		return localVarReturnValue, nil, reportError("mutingSchedulesLibraryBaseExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mutingSchedulesLibraryBaseExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMutingSchedulesReadByIdRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
	id string
}

func (r ApiMutingSchedulesReadByIdRequest) Execute() (*MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	return r.ApiService.MutingSchedulesReadByIdExecute(r)
}

/*
MutingSchedulesReadById Get a mutingschedule or folder.

Get a mutingschedule or folder from the mutingSchedules library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifier of the mutingschedule or folder to read.
 @return ApiMutingSchedulesReadByIdRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesReadById(ctx context.Context, id string) ApiMutingSchedulesReadByIdRequest {
	return ApiMutingSchedulesReadByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MutingSchedulesLibraryBaseResponse
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesReadByIdExecute(r ApiMutingSchedulesReadByIdRequest) (*MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MutingSchedulesLibraryBaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.MutingSchedulesReadById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMutingSchedulesReadByIdsRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
	ids *[]string
	skipChildren *bool
}

// A comma-separated list of identifiers.
func (r ApiMutingSchedulesReadByIdsRequest) Ids(ids []string) ApiMutingSchedulesReadByIdsRequest {
	r.ids = &ids
	return r
}

// a boolean parameter to control skipping fetching children of requested folder(s)
func (r ApiMutingSchedulesReadByIdsRequest) SkipChildren(skipChildren bool) ApiMutingSchedulesReadByIdsRequest {
	r.skipChildren = &skipChildren
	return r
}

func (r ApiMutingSchedulesReadByIdsRequest) Execute() (*map[string]MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	return r.ApiService.MutingSchedulesReadByIdsExecute(r)
}

/*
MutingSchedulesReadByIds Bulk read a mutingschedule or folder.

Bulk read a mutingschedule or folder by the given identifiers from the mutingSchedules library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMutingSchedulesReadByIdsRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesReadByIds(ctx context.Context) ApiMutingSchedulesReadByIdsRequest {
	return ApiMutingSchedulesReadByIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]MutingSchedulesLibraryBaseResponse
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesReadByIdsExecute(r ApiMutingSchedulesReadByIdsRequest) (*map[string]MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]MutingSchedulesLibraryBaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.MutingSchedulesReadByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.skipChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipChildren", r.skipChildren, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMutingSchedulesSearchRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
	query *string
	limit *int32
	offset *int32
	skipChildren *bool
}

// The search query to find mutingschedule or folder. Below is the list of different filters with examples:   - **createdBy** : Filter by the user&#39;s identifier who created the content. Example: &#x60;createdBy:000000000000968B&#x60;.   - **createdBefore** : Filter by the content objects created before the given timestamp(in milliseconds). Example: &#x60;createdBefore:1457997222&#x60;.   - **createdAfter** : Filter by the content objects created after the given timestamp(in milliseconds). Example: &#x60;createdAfter:1457997111&#x60;.   - **modifiedBefore** : Filter by the content objects modified before the given timestamp(in milliseconds). Example: &#x60;modifiedBefore:1457997222&#x60;.   - **modifiedAfter** : Filter by the content objects modified after the given timestamp(in milliseconds). Example: &#x60;modifiedAfter:1457997111&#x60;.   - **type** : Filter by the type of the content object. Example: &#x60;type:folder&#x60;.  You can also use multiple filters in one query. For example to search for all content objects created by user with identifier 000000000000968B with creation timestamp after 1457997222 containing the text Test, the query would look like:    &#x60;createdBy:000000000000968B createdAfter:1457997222 Test&#x60;
func (r ApiMutingSchedulesSearchRequest) Query(query string) ApiMutingSchedulesSearchRequest {
	r.query = &query
	return r
}

// Maximum number of items you want in the response.
func (r ApiMutingSchedulesSearchRequest) Limit(limit int32) ApiMutingSchedulesSearchRequest {
	r.limit = &limit
	return r
}

// The position or row from where to start the search operation.
func (r ApiMutingSchedulesSearchRequest) Offset(offset int32) ApiMutingSchedulesSearchRequest {
	r.offset = &offset
	return r
}

// a boolean parameter to control skipping fetching children of requested folder(s)
func (r ApiMutingSchedulesSearchRequest) SkipChildren(skipChildren bool) ApiMutingSchedulesSearchRequest {
	r.skipChildren = &skipChildren
	return r
}

func (r ApiMutingSchedulesSearchRequest) Execute() ([]MutingSchedulesLibraryItemWithPath, *http.Response, error) {
	return r.ApiService.MutingSchedulesSearchExecute(r)
}

/*
MutingSchedulesSearch Search for a mutingschedule or folder.

Search for a mutingschedule or folder in the mutingSchedules library structure.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMutingSchedulesSearchRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesSearch(ctx context.Context) ApiMutingSchedulesSearchRequest {
	return ApiMutingSchedulesSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MutingSchedulesLibraryItemWithPath
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesSearchExecute(r ApiMutingSchedulesSearchRequest) ([]MutingSchedulesLibraryItemWithPath, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MutingSchedulesLibraryItemWithPath
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.MutingSchedulesSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.skipChildren != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipChildren", r.skipChildren, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMutingSchedulesUpdateByIdRequest struct {
	ctx context.Context
	ApiService *MutingSchedulesLibraryManagementApiService
	id string
	mutingSchedulesLibraryBaseUpdate *MutingSchedulesLibraryBaseUpdate
}

// The mutingschedule or folder to update. The content version must match its latest version number in the mutingSchedules library. If the version does not match it will not be updated.
func (r ApiMutingSchedulesUpdateByIdRequest) MutingSchedulesLibraryBaseUpdate(mutingSchedulesLibraryBaseUpdate MutingSchedulesLibraryBaseUpdate) ApiMutingSchedulesUpdateByIdRequest {
	r.mutingSchedulesLibraryBaseUpdate = &mutingSchedulesLibraryBaseUpdate
	return r
}

func (r ApiMutingSchedulesUpdateByIdRequest) Execute() (*MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	return r.ApiService.MutingSchedulesUpdateByIdExecute(r)
}

/*
MutingSchedulesUpdateById Update a mutingschedule or folder. 

Update a mutingschedule or folder in the mutingSchedules library.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Identifier of the mutingschedule or folder to update.
 @return ApiMutingSchedulesUpdateByIdRequest
*/
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesUpdateById(ctx context.Context, id string) ApiMutingSchedulesUpdateByIdRequest {
	return ApiMutingSchedulesUpdateByIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MutingSchedulesLibraryBaseResponse
func (a *MutingSchedulesLibraryManagementApiService) MutingSchedulesUpdateByIdExecute(r ApiMutingSchedulesUpdateByIdRequest) (*MutingSchedulesLibraryBaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MutingSchedulesLibraryBaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MutingSchedulesLibraryManagementApiService.MutingSchedulesUpdateById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/mutingSchedules/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mutingSchedulesLibraryBaseUpdate == nil {
		return localVarReturnValue, nil, reportError("mutingSchedulesLibraryBaseUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mutingSchedulesLibraryBaseUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
