/*
Sumo Logic API

Go client for Sumo Logic API. 

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sumologic

import (
	"encoding/json"
)

// checks if the EstimatedUsageDetailsWithMeteringType type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &EstimatedUsageDetailsWithMeteringType{}

// EstimatedUsageDetailsWithMeteringType Estimated Usage details for the given log search query with the above timerange.
type EstimatedUsageDetailsWithMeteringType struct {
	// Name of the metering type. Metering type indicates how the data scanned within a particular data tier is actually metered and billed. Supported Values are Continuous, Frequent, Infrequent, ContinuousSecurity and FlexSecurity. 
	MeteringType *string `json:"meteringType,omitempty"`
	// Amount of data scanned in bytes, to run the query.
	DataScannedInBytes *int64 `json:"dataScannedInBytes,omitempty"`
	// Name of the data tier. Supported Values are Continuous, Frequent, Infrequent and Flex.
	Tier *string `json:"tier,omitempty"`
	// Whether particular metering type is accounted against a customer's credit on a per scan basis.  e.g Data belonging to \"Flex\" and \"Infrequent\" metering type is accounted for credits on per scan basis. For other metering types, eg. \"Continuous\" it's charged upfront during ingestion. 
	ScanCreditAccounted *bool `json:"scanCreditAccounted,omitempty"`
}

// NewEstimatedUsageDetailsWithMeteringType instantiates a new EstimatedUsageDetailsWithMeteringType object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewEstimatedUsageDetailsWithMeteringType() *EstimatedUsageDetailsWithMeteringType {
	this := EstimatedUsageDetailsWithMeteringType{}
	return &this
}

// NewEstimatedUsageDetailsWithMeteringTypeWithDefaults instantiates a new EstimatedUsageDetailsWithMeteringType object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewEstimatedUsageDetailsWithMeteringTypeWithDefaults() *EstimatedUsageDetailsWithMeteringType {
	this := EstimatedUsageDetailsWithMeteringType{}
	return &this
}

// GetMeteringType returns the MeteringType field value if set, zero value otherwise.
func (o *EstimatedUsageDetailsWithMeteringType) GetMeteringType() string {
	if o == nil || IsNil(o.MeteringType) {
		var ret string
		return ret
	}
	return *o.MeteringType
}

// GetMeteringTypeOk returns a tuple with the MeteringType field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *EstimatedUsageDetailsWithMeteringType) GetMeteringTypeOk() (*string, bool) {
	if o == nil || IsNil(o.MeteringType) {
		return nil, false
	}
	return o.MeteringType, true
}

// HasMeteringType returns a boolean if a field has been set.
func (o *EstimatedUsageDetailsWithMeteringType) HasMeteringType() bool {
	if o != nil && !IsNil(o.MeteringType) {
		return true
	}

	return false
}

// SetMeteringType gets a reference to the given string and assigns it to the MeteringType field.
func (o *EstimatedUsageDetailsWithMeteringType) SetMeteringType(v string) {
	o.MeteringType = &v
}

// GetDataScannedInBytes returns the DataScannedInBytes field value if set, zero value otherwise.
func (o *EstimatedUsageDetailsWithMeteringType) GetDataScannedInBytes() int64 {
	if o == nil || IsNil(o.DataScannedInBytes) {
		var ret int64
		return ret
	}
	return *o.DataScannedInBytes
}

// GetDataScannedInBytesOk returns a tuple with the DataScannedInBytes field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *EstimatedUsageDetailsWithMeteringType) GetDataScannedInBytesOk() (*int64, bool) {
	if o == nil || IsNil(o.DataScannedInBytes) {
		return nil, false
	}
	return o.DataScannedInBytes, true
}

// HasDataScannedInBytes returns a boolean if a field has been set.
func (o *EstimatedUsageDetailsWithMeteringType) HasDataScannedInBytes() bool {
	if o != nil && !IsNil(o.DataScannedInBytes) {
		return true
	}

	return false
}

// SetDataScannedInBytes gets a reference to the given int64 and assigns it to the DataScannedInBytes field.
func (o *EstimatedUsageDetailsWithMeteringType) SetDataScannedInBytes(v int64) {
	o.DataScannedInBytes = &v
}

// GetTier returns the Tier field value if set, zero value otherwise.
func (o *EstimatedUsageDetailsWithMeteringType) GetTier() string {
	if o == nil || IsNil(o.Tier) {
		var ret string
		return ret
	}
	return *o.Tier
}

// GetTierOk returns a tuple with the Tier field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *EstimatedUsageDetailsWithMeteringType) GetTierOk() (*string, bool) {
	if o == nil || IsNil(o.Tier) {
		return nil, false
	}
	return o.Tier, true
}

// HasTier returns a boolean if a field has been set.
func (o *EstimatedUsageDetailsWithMeteringType) HasTier() bool {
	if o != nil && !IsNil(o.Tier) {
		return true
	}

	return false
}

// SetTier gets a reference to the given string and assigns it to the Tier field.
func (o *EstimatedUsageDetailsWithMeteringType) SetTier(v string) {
	o.Tier = &v
}

// GetScanCreditAccounted returns the ScanCreditAccounted field value if set, zero value otherwise.
func (o *EstimatedUsageDetailsWithMeteringType) GetScanCreditAccounted() bool {
	if o == nil || IsNil(o.ScanCreditAccounted) {
		var ret bool
		return ret
	}
	return *o.ScanCreditAccounted
}

// GetScanCreditAccountedOk returns a tuple with the ScanCreditAccounted field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *EstimatedUsageDetailsWithMeteringType) GetScanCreditAccountedOk() (*bool, bool) {
	if o == nil || IsNil(o.ScanCreditAccounted) {
		return nil, false
	}
	return o.ScanCreditAccounted, true
}

// HasScanCreditAccounted returns a boolean if a field has been set.
func (o *EstimatedUsageDetailsWithMeteringType) HasScanCreditAccounted() bool {
	if o != nil && !IsNil(o.ScanCreditAccounted) {
		return true
	}

	return false
}

// SetScanCreditAccounted gets a reference to the given bool and assigns it to the ScanCreditAccounted field.
func (o *EstimatedUsageDetailsWithMeteringType) SetScanCreditAccounted(v bool) {
	o.ScanCreditAccounted = &v
}

func (o EstimatedUsageDetailsWithMeteringType) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o EstimatedUsageDetailsWithMeteringType) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.MeteringType) {
		toSerialize["meteringType"] = o.MeteringType
	}
	if !IsNil(o.DataScannedInBytes) {
		toSerialize["dataScannedInBytes"] = o.DataScannedInBytes
	}
	if !IsNil(o.Tier) {
		toSerialize["tier"] = o.Tier
	}
	if !IsNil(o.ScanCreditAccounted) {
		toSerialize["scanCreditAccounted"] = o.ScanCreditAccounted
	}
	return toSerialize, nil
}

type NullableEstimatedUsageDetailsWithMeteringType struct {
	value *EstimatedUsageDetailsWithMeteringType
	isSet bool
}

func (v NullableEstimatedUsageDetailsWithMeteringType) Get() *EstimatedUsageDetailsWithMeteringType {
	return v.value
}

func (v *NullableEstimatedUsageDetailsWithMeteringType) Set(val *EstimatedUsageDetailsWithMeteringType) {
	v.value = val
	v.isSet = true
}

func (v NullableEstimatedUsageDetailsWithMeteringType) IsSet() bool {
	return v.isSet
}

func (v *NullableEstimatedUsageDetailsWithMeteringType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableEstimatedUsageDetailsWithMeteringType(val *EstimatedUsageDetailsWithMeteringType) *NullableEstimatedUsageDetailsWithMeteringType {
	return &NullableEstimatedUsageDetailsWithMeteringType{value: val, isSet: true}
}

func (v NullableEstimatedUsageDetailsWithMeteringType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableEstimatedUsageDetailsWithMeteringType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


